#死锁
##产生死锁的必要条件
死锁就是两个或者多个进程，互相请求对方占有的资源。</br>
1、互斥条件：一个资源每次只能被一个进程使用。</br>
2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</br>
3、不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</br>
4、循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</br>
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
一不满足，就不会发生死锁。
##代码分析
###关键字synchronized
这个关键字用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。当一个线程访问object的一个synchronized同步代码块或同步方法时，其他线程将对object中所有其他synchronized同步代码块或同步方法的访问将被阻塞。</br></br>
![2](http://yotuku.cn/link?url=N16lh_6gf&tk_plan=free&tk_storage=tietuku&tk_vuid=9ace458f-719f-4101-a610-9699b1a2d3ee&tk_time=2016111023)</br>
在死锁的类中定义了两个对象A和B作为成员变量。</br>
在主函数main中直接new了一个死锁的对象，然后程序就会自动的调用默认构造函数。在默认构造函数中，定义了一个线程t，当线程t调用了start函数之后，线程t就会被插入到调度队列中，当调度到他的时候，就会跑run（）里面的代码，需要注意的是地锁类是Runnable的一个子类，在java中就是多线程，当每次调度到该线程的时候，就会自动的执行重载后的run函数。
##死锁截图
![1](http://yotuku.cn/link?url=V1CdOuTlG&tk_plan=free&tk_storage=tietuku&tk_vuid=9ace458f-719f-4101-a610-9699b1a2d3ee&tk_time=2016111022)

可以看到运行到第561次的时候程序停了下来，也就是产生了死锁。有可能是系统的原因，我运行了几次才发生死锁，有时候是不会停下来的。